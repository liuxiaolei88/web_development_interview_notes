# 网络总结

## Q1: GET和POST的请求的区别

- 应用场景：Get是一个幂等请求，一般用于请求资源。post不是幂等请求，一般用于修改资源。
- 缓存：Get请求一般缓存，Post一般不缓存
- 报文格式：Get请求体一般为空，Post一般携带数据
- 安全性：Get请求将参数放入URL，URL一般缓存，安全性比post差
- 请求长度：Get比post短，因为url长度限制
- 参数类型：post支持更多数据类型

## Q2:  POST和PUT请求的区别

- put一般用来更新数据
- post一般用来新增数据

## Q3:常见的HTTP请求头和响应头

### **HTTP Request Header 常见的请求头：**

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

### **HTTP Responses Header 常见的响应头：**

- Date：表示消息发送的时间，时间的描述格式由rfc822定义

- server:服务器名称

- Connection：浏览器与服务器之间连接的类型

- Cache-Control：控制HTTP缓存

- content-type:表示后面的文档属于什么MIME类型


post请求常见的content-type

  1. application/x-www-form-urlencoded: 最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性.
  2. multipart/form-data: 使用表单上传文件时，必须让 form 的 enctyped 等于这个值。一般用来上传文件。
  3. application/json：告诉服务端消息主体是序列化后的 JSON 字符串。上传复杂的结构化数据。
  4. text/xml：使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。

## Q4: 常见的HTTP请求方法

​	一共8种

- GET：向服务器请求数据
- POST：提交、更改数据
- PUT：更新数据
- DELETE：删除数据
- HEAD：获取报文头部，不返回报文主体
- OPTIONS：询问支持的请求方法，用于跨域请求
- CONNECT：建立隧道
- TRACE：测试、诊断

## Q5: Options请求

​	options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。

某些请求不会触发CORS预检请求，这样的请求一般称为 **“简单请求”** ，而会触发预检的请求则是 **“复杂请求”** 。

简单请求

- 请求方式为`GET、HEAD、POST`时的请求；
- 认为设置规范集合之内的首部字段，如`Accept/Accept-Language/Content-Language/Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width`;
- Content-Type 的值仅限于下列三者之一,即`application/x-www-form-urlencoded、multipart/form-data、text/plain`；
- 请求中的任意 `XMLHttpRequestUpload`对象均没有注册任何事件监听器；
- 请求中没有使用 `ReadableStream`对象。

复杂请求

- PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH;
- 人为设置了以下集合之外首部字段，即简单请求外的字段;
- Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain。

参考链接

- https://blog.csdn.net/weixin_45943355/article/details/125223919

## Q6: HTTP的请求报文、响应报文结构

### 请求报文结构

- 请求⾏ ：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 
- 请求头部 ：请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  
  - User-Agent：产⽣请求的浏览器类型。 
  - Accept：客户端可识别的内容类型列表。 
  - Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。 
- 空⾏
- 请求体: post put等请求携带的数据 

### 请求响应结构: 

- 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。 
- 响应头：响应部⾸组成 
- 空⾏
- 响应体：服务器响应的数据 

## Q7: HTTP的各种版本

### HTTP1.0

-  默认使用非持久连接
- 不支持只使用资源的一部分，不支持断点续传
- 使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准
- 认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名（hostname）

### HTTP1.1

- 持久连接来使多个 http 请求复用同一个 TCP 连接
- 请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）
- 更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等
- 新增了 host 字段，用来指定服务器的域名
- 新增请求方法，如 PUT、HEAD、OPTIONS 等。

### HTTP2.0

- 一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。
- 在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"
- 每个请求或回应的所有数据包为一个数据流，每个数据流都有一个独一无二的编号。但数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
- 引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了。
- 允许服务器未经请求，主动向客户端发送资源

### HTTP3.0

- HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。
- 流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
- 集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
- 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。

## Q8: 网址解析过程

当在浏览器中输入 Google.com 并且按下回车之后发生了什么？

### 解析url

​	分析使用什么传输协议、请求路径

### 缓存判断

​	如果有资源则直接使用，没有资源则需要请求

### DNS解析

​	获得url中域名对应的ip。

- 本地DNS服务器
- DNS根域名服务器
- DNS顶级域名服务器
- DNS权威域名服务器：获得最后域名对应的ip，返回用户

### MAC地址解析

​	下发链路层，将本机的MAC地址作为源mac，目的MAC需要分情况。如果在一个子网，可以使用ARP进行地址翻译，如果不在一个子网则发送到网关代发，然后再用APR翻译得到真实MAC地址

### TCP三次握手

- 客户端向服务器发送第一次请求：SYN和一个随机序号
- 收到后，服务器向客户端发送请求：SYN ACK确认请求链接，后随机发送一个序号
- 客户端向服务器发送一个确认ACK

### HTTPS握手

​	如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。

- 客户端向服务器发送协议版本号、一个随机数和可以使用的加密方法。
- 服务器端收到后，确认加密方法，也向客户端发送一个随机数和自己的数字证书。
- 客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。
- 服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。
- 这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

### 返回数据

​	返回html文件

### 页面渲染

- 根据html创建DOM树，根据css创建cssom树，遇到script还要判断 defer 或者async ，不然会导致页面渲染阻塞
- 当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树
- 渲染树构建好后，会根据渲染树来进行布局
- 最后使用浏览器的 UI 接口对页面进行绘制

### TCP四次挥手

- 客户端向服务器端发送FIN，告诉服务器自己要释放链接
- 服务器接收到以后向客户端发ack，客户端进入 CLOSE_WAIT 状态，不再向服务器发送数据。此时服务器端还可以给客户端发送数据。
- 当服务器数据发送完毕，向客户端发送fin，服务器进入LAST_ACK
- 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。



![](https://img-blog.csdnimg.cn/20200829113323236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70)



## Q9: Cookie、Session、Token

- Cookie：一种以键值对存储在浏览器的数据
- session：在用户发送用户名密码校验成功后，服务器会返回sessionid和session的事件进行set Cookie，等客户端下次请求则会自动带上cookie
- token：若使用多台服务器进行存储sessionid，则需要共享，所以产生了jwt，也就是token。当用户发送用户名密码，服务端校验成功以后会会返回token，token可以以storage或者cookie的形式进行保存，服务器端则是保存了签名密文。token有三部分：header（使用什么算法生成签名）、payload（特定的数据，如有效期）、signature。然后header和payload会使用base64编码，结合这两段编码和header声明的算法得到signature那部分。等待下一次登陆，可以直接使用token登陆，不需要输入用户名密码。

## Q10: HTTP状态码

### 2xx (Success 成功状态码)

- 200 OK：正常处理
- 204 No Content：请求正常处理，但没有返回内容
- 206 Partial Content：响应了报文中包含由 Content-Range 指定范围的实体内容。

###  3XX (Redirection 重定向状态码)

​	表明浏览器需要执行某些特殊的处理以正确处理请求	

- 301 Moved Permanently

  - 永久重定向。
  - 表示请求的资源已经被分配了新的 URI，新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。
  - 书签会自动更改地址

- 302 Found

  - 临时重定向
  - 移动的资源对应的 URI 将来还有可能发生改变
  - 书签不会自动更改地址

- 303 See Other

  - 请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。
  - 303 状态码通常作为 PUT 或 POST 操作的返回结果

- 304 Not Modified

  - 状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。

- 307 Temporary Redirect

  - 临时重定向

  - 307 会遵守浏览器标准，**不会从 POST 变成 GET**。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。

### 4XX (Client Error 客户端错误状态码)

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

### 5XX (Server Error 服务器错误状态码)

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

## Q11: keep-alive

HTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是**短连接**。

当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是**长连接**。其使用方法如下：

- HTTP1.0版本是默认没有Keep-alive，须手动配置发送`Connection: keep-alive`字段。若想断开keep-alive连接，需发送`Connection:close`字段；
- HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送`Connection：close`首部字段。

## Q12: 强制缓存/协商缓存

- 强缓存：
  - 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本**次请求根本就不会与服务器进行通信。**
  - 使用头部
    - Expires
    - Cache-Control


- 协商缓存：

  - 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；

  - 若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，**但是并不返回资源内容，它会告知浏览器可以直接从缓存获取**；否则返回最新的资源内容。

  - 使用头部

    - Etag、If-None-Match
    - Last-Modified、If-Modified-Since

    





## Q13: 什么是HTTPS？

- HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。
- HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

## Q14: HTTP和HTTPS协议的区别？

- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
- HTTP协议端口是80，HTTPS协议端口是443；
- HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

## Q15: ssl加密使用了哪种算法，如何加密？

1. 在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。
2. 公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。

## Q16: 用户登陆过程的简要说明，如何判断用户是否登录？

- 用户输入用户名和密码，通过post请求将密码和用户名发送给服务器，服务器比对收到的用户名、密码和数据库中的数据进行比对，不一致则做出响应，反馈信息给客户端
- 如果比对一致则服务端生成一个session，这个session可以存储在内存、文件、数据库中，同时生成一个与之一一对应的sessionID作为cookie发送给客户端，比对成功之后反馈信息，这时一般会进行一次重定向，重定向至登陆之后的默认页面。
- 判断用户登录则是根据这个sessionID，每次请求会先检查有没有这次类似sessionID的cookie发送过来，没有则认为没有登录，有则是否有相应的session，这个session是否过期等，来判断用户是否登录，登录是否过期。

## Q17: tcp和udp的区别

- TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
- TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- TCP连接只能是点到点、一对一的。UDP支持一对一，一对多，多对一和多对多的交互通信。
- TCP的首部较大为20字节，而UDP只有8字节。



## Q18: OSI七层模型

#### （1）应用层

`OSI`参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：`HTTP`，`HTTPS`，`FTP`，`POP3`、`SMTP`等。

#### （2）表示层

表示层提供各种用于应用层**数据的编码和转换功**能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。**数据压缩和加密**也是表示层可提供的转换功能之一。

#### （3）会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。

#### （4）传输层

传输层建立了主机**端到端**的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，`TCP` `UDP`就是在这一层。端口号既是这里的“端”。

#### （5）网络层

本层通过`IP`寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。

#### （6）数据链路层

将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

#### （7）物理层

通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。



![image](https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp)

